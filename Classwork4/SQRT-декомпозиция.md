## SQRT-декомпозиция

SQRT-декомпозиция может встретиться в разных задачах под разным видом. Главный смысл в том,
чтобы разделить входные данные на блоки, 
где размер блока порядка корня, от размера входных данных.

Самый простой вариант: корневая декомпозиция на массиве. 

[Сумма и увеличение одного элемента](https://wiki.algocode.ru/index.php?title=%D0%9A%D0%BE%D1%80%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D0%B4%D0%B5%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F_%D0%BD%D0%B0_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B5) 

Задача **Лунки** из классной работы:

Разделим ряд на блоки длины K=sqrt(N) подряд идущих лунок. Если N не является полным квадратом, то K=sqrt(N), округленное вниз. Для каждой лунки помимо силы ее выброса (power[i]) запомним первую лунку из другого блока, в которую из нее можно попасть при помощи последовательных прыжков (будем считать что за краем ряда находится фиктивная лунка из отдельного блока, в которую мы попадаем при вылете за край из любой лунки) - next[i]. Так же для каждой лунки запомним количество прыжков, требуемое для того чтобы попасть в первую лунку из другого блока  - count[i].

Для того чтобы обработать запрос вбрасывания шарика, просто из лунки i будем перепрыгивать сразу в next[i], прибавляя к ответу count[i], пока не придем в фиктивную лунку. Таким образом мы сделаем не более N/K прыжков.
Для обработки запроса изменения силы лунки i, в начале поменяем power[i], count[i] и next[i], а затем для всех лунок из того же блока что и i, которые находятся раньше i в порядке убывания обновим next и count. Таким образом мы сделаем не более K обновлений.

Сложность алгоритма выходит O(Nsqrt(N)).

### Более сложные задачи


Сложная задача(опциональная): дан массив размера n, приходит q запросов вида (перевернуть отрезок массива с l по r), и (посчитать сумму на отрезках с l по r).

Разделим массив на блоки, размера k. В каждом блоке будем хранить сумму элементов в этом блоке и сами элементы. Также будем хранить флаг, правда ли элементы внутри блока лежат в нужном порядке, или же их нужно перевернуть.

Операцию переворачивания будем обрабатывать так:

Смотрим, какие блоки полностью попали в отрезок запроса, слева и справа от них могут быть блоки, которые попали частично.

Чтобы перевернуть элементы внутри блока, просто запишем в флаг этого блока, что элементы там перевернуты. В тех блоках, которые попали не полностью, честно перевернем ту часть, которая попала в запрос. Также заметим, что недостаточно просто перевернуть элементы внутри блоков, нужно поменять порядок и самих блоков. Чтобы это сделать быстро, будем хранить массив указателей на блоки(или же хранить блоки в массиве, а адреса блоков будут индексы в этом массиве). Когда приходит запрос на переворот, будем переворачивать сами блоки в этом массиве блоков(помимо того, что нужно сделать для самих блоков).

Итого, это работает за

1. 2 * k -- честно перевернуть элементы в крайних блоках
2. n / k - проставить флаги в блоках
3. n / k - поменять порядок самих блоков.


$$O(k + \frac{n}{k})$$

Как будем отвечать на запрос суммы? Посмотрим, какие блоки полностью попали в запрос, у них спросим полностью сумму, которая уже посчитана для любого блока и хранится вместе с блоком - O(n / k). А для крайних блоков честно пробежимся по элементам и посчитаем сумму - O(2 * k).

$$O(k + \frac{n}{k})$$

Итого, какой k нужно взять? Несложно показать, что самый лучший k здесь будет $k = \sqrt{n}$.

_Стоит отметить, что помимо того, что написано выше, для каждого блока, если мы честно пробегаемся по его элементам, нужно посмотреть на его флаг, и если что перевернуть его элементы_

Однако задача на этом не заканчивается. Дело в том, что иногда просто переворачивать сами блоки тоже не совсем верно. Так можно делать, только если отрезок попал ровно в границы блоков. Если это не так, то те крайние блоки, которые частично попали в запрос, нужно разделить на 2 блока каждый. А затем после этого уже переворачивать блоки. С другой стороны, если так делать, то кол-во блоков будет расти, поэтому помимо этого нужно иногда наоборот объединять блоки, если мы видим несколько подряд идущих блоков(чтобы их суммарный размер стал порядка корня). Это можно делать, например, во время поиска блоков для отрезка, который нас интересует. Асимптотика от этого не меняется, но несколько сложностей появляется.


--------

Есть задачи, где k не является корнем из n, он может быть корнем из n * log(n) или нечто другое, и зависит это от самой задачи. Считаете асимптотику и понимаете, какой k лучше подходит.

--------

## Алгоритм МО

Еще 1 вариант декомпозиции, но тут скорее делятся сами запросы, а не массив. Есть отдельный пул задач, которые можно решить с его помощью.

[ссылка](https://ru.algorithmica.org/cs/decomposition/mo/)

