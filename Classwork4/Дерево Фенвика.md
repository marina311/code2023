## Дерево Фенвика

[Статья с объяснениями на алгоритмике](https://algorithmica.org/ru/fenwick) (ее в принципе достаточно)

[Еще 1 статья](https://wiki.algocode.ru/index.php?title=%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%A4%D0%B5%D0%BD%D0%B2%D0%B8%D0%BA%D0%B0)

[Для совсем гурманов есть лекция, где всё объясняется еще более подробно](https://www.youtube.com/watch?v=Sy38fgiwkkA)

[Как делать прибавление на подотрезке](https://blog.mitrichev.ch/2013/05/fenwick-tree-range-updates.html)

[Встречное дерево фенвика*](https://codeforces.com/blog/entry/69136)


Есть несколько вариантов написания функций перехода, более простой и понятный использует массив в 1 индексации и выглядит так:

```c++
int sum (int i) {
    int res = 0;
    for (; i > 0; i -= i & -i)
        res += t[i];
    return res;
}

int sum (int l, int r) {
    return sum(r) - sum(l-1);
}

// обновляет нужные t
void add (int i, int x) {
    for (; i <= n; i += i & -i)
        t[i] += x;
}
```

Это и есть весь код. 

В классной работе используется двумерное дерево Фенвика. Отличается от описанного только вложенным циклом и использованием формулы включений и исключений. 

В домашней (задача **Звезды**) - трехмерное (и та же формула, только для трех измерений).

Задача **ФФенвик** (есть сразу в домашней и итоговой работах) использует идею вложенного дерева Фенвика. 
1. Используем сжатие координат по Х, чтобы свести к обычному массиву.
2. На каждом интервале, за который отвечает вершина дерева, строим отдельное дерево по y, учитывая только те координаты y, которые используются в этом поддереве.    
Т.е. пробегаем по такому циклу ```for (; i <= n; i += i & -i)``` и добавляем в массив все значения y, которые нам встретятся. Дальше на каждом таком массиве тоже сжимаем координаты и строим отдельное дерево фенвика. 
3. Нужные индексы x и y в сжатых массивах находим бинпоиском.

